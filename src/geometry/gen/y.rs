////////////////////////////////////////////////////////////////////////////////
// ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ This file is @generated by build script. ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ //
// ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§           â›” DO NOT MODIFY! â›”           ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ //
////////////////////////////////////////////////////////////////////////////////

use super::*;

/// An [`Y`](crate::Y) coordinate.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Default, Debug)]
pub struct Y(pub usize);

// ========================================================================== //
// ========================================================================== //
//                                   Derefs                                   //
// ========================================================================== //
// ========================================================================== //

impl Deref for Y {
    type Target = usize;

    fn deref(&self) -> &usize {
        &self.0
    }
}

impl DerefMut for Y {
    fn deref_mut(&mut self) -> &mut usize {
        &mut self.0
    }
}

// ========================================================================== //
// ========================================================================== //
//                                Conversions                                 //
// ========================================================================== //
// ========================================================================== //

impl From<Y> for usize {
    fn from(y: Y) -> Self {
        y.0
    }
}

impl From<usize> for Y {
    fn from(y: usize) -> Self {
        Self(y)
    }
}

impl From<X> for Y {
    fn from(X(y): X) -> Self {
        Self(y)
    }
}

impl From<Width> for Y {
    fn from(Width(y): Width) -> Self {
        Self(y)
    }
}

impl From<Height> for Y {
    fn from(Height(y): Height) -> Self {
        Self(y)
    }
}

// ========================================================================== //
// ========================================================================== //
//                                 Operations                                 //
// ========================================================================== //
// ========================================================================== //

impl Not for Y {
    type Output = Self;

    fn not(self) -> Self {
        Self { 0: self.0.not() }
    }
}

impl Add for Y {
    type Output = Self;

    fn add(self, rhs: Self) -> Self {
        Self {
            0: self.0.add(rhs.0),
        }
    }
}

impl AddAssign for Y {
    fn add_assign(&mut self, rhs: Self) {
        self.0.add_assign(rhs.0);
    }
}

impl Sub for Y {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self {
        Self {
            0: self.0.sub(rhs.0),
        }
    }
}

impl SubAssign for Y {
    fn sub_assign(&mut self, rhs: Self) {
        self.0.sub_assign(rhs.0);
    }
}

impl Mul for Y {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self {
        Self {
            0: self.0.mul(rhs.0),
        }
    }
}

impl MulAssign for Y {
    fn mul_assign(&mut self, rhs: Self) {
        self.0.mul_assign(rhs.0);
    }
}

impl Div for Y {
    type Output = Self;

    fn div(self, rhs: Self) -> Self {
        Self {
            0: self.0.div(rhs.0),
        }
    }
}

impl DivAssign for Y {
    fn div_assign(&mut self, rhs: Self) {
        self.0.div_assign(rhs.0);
    }
}

impl Rem for Y {
    type Output = Self;

    fn rem(self, rhs: Self) -> Self {
        Self {
            0: self.0.rem(rhs.0),
        }
    }
}

impl RemAssign for Y {
    fn rem_assign(&mut self, rhs: Self) {
        self.0.rem_assign(rhs.0);
    }
}

impl Shl for Y {
    type Output = Self;

    fn shl(self, rhs: Self) -> Self {
        Self {
            0: self.0.shl(rhs.0),
        }
    }
}

impl ShlAssign for Y {
    fn shl_assign(&mut self, rhs: Self) {
        self.0.shl_assign(rhs.0);
    }
}

impl Shr for Y {
    type Output = Self;

    fn shr(self, rhs: Self) -> Self {
        Self {
            0: self.0.shr(rhs.0),
        }
    }
}

impl ShrAssign for Y {
    fn shr_assign(&mut self, rhs: Self) {
        self.0.shr_assign(rhs.0);
    }
}

impl BitAnd for Y {
    type Output = Self;

    fn bitand(self, rhs: Self) -> Self {
        Self {
            0: self.0.bitand(rhs.0),
        }
    }
}

impl BitAndAssign for Y {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0);
    }
}

impl BitOr for Y {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Self {
        Self {
            0: self.0.bitor(rhs.0),
        }
    }
}

impl BitOrAssign for Y {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0);
    }
}

impl BitXor for Y {
    type Output = Self;

    fn bitxor(self, rhs: Self) -> Self {
        Self {
            0: self.0.bitxor(rhs.0),
        }
    }
}

impl BitXorAssign for Y {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0.bitxor_assign(rhs.0);
    }
}
