////////////////////////////////////////////////////////////////////////////////
// ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ This file is @generated by build script. ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ //
// ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§           â›” DO NOT MODIFY! â›”           ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ //
////////////////////////////////////////////////////////////////////////////////

use super::*;

/// An [`X`](crate::X) coordinate.
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Default, Debug)]
pub struct X(pub usize);

// ========================================================================== //
// ========================================================================== //
//                                   Derefs                                   //
// ========================================================================== //
// ========================================================================== //

impl Deref for X {
    type Target = usize;

    fn deref(&self) -> &usize {
        &self.0
    }
}

impl DerefMut for X {
    fn deref_mut(&mut self) -> &mut usize {
        &mut self.0
    }
}

// ========================================================================== //
// ========================================================================== //
//                                Conversions                                 //
// ========================================================================== //
// ========================================================================== //

impl From<X> for usize {
    fn from(x: X) -> Self {
        x.0
    }
}

impl From<usize> for X {
    fn from(x: usize) -> Self {
        Self(x)
    }
}

impl From<Y> for X {
    fn from(Y(x): Y) -> Self {
        Self(x)
    }
}

impl From<Width> for X {
    fn from(Width(x): Width) -> Self {
        Self(x)
    }
}

impl From<Height> for X {
    fn from(Height(x): Height) -> Self {
        Self(x)
    }
}

// ========================================================================== //
// ========================================================================== //
//                                 Operations                                 //
// ========================================================================== //
// ========================================================================== //

impl Not for X {
    type Output = Self;

    fn not(self) -> Self {
        Self { 0: self.0.not() }
    }
}

impl Add for X {
    type Output = Self;

    fn add(self, rhs: Self) -> Self {
        Self {
            0: self.0.add(rhs.0),
        }
    }
}

impl AddAssign for X {
    fn add_assign(&mut self, rhs: Self) {
        self.0.add_assign(rhs.0);
    }
}

impl Sub for X {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self {
        Self {
            0: self.0.sub(rhs.0),
        }
    }
}

impl SubAssign for X {
    fn sub_assign(&mut self, rhs: Self) {
        self.0.sub_assign(rhs.0);
    }
}

impl Mul for X {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self {
        Self {
            0: self.0.mul(rhs.0),
        }
    }
}

impl MulAssign for X {
    fn mul_assign(&mut self, rhs: Self) {
        self.0.mul_assign(rhs.0);
    }
}

impl Div for X {
    type Output = Self;

    fn div(self, rhs: Self) -> Self {
        Self {
            0: self.0.div(rhs.0),
        }
    }
}

impl DivAssign for X {
    fn div_assign(&mut self, rhs: Self) {
        self.0.div_assign(rhs.0);
    }
}

impl Rem for X {
    type Output = Self;

    fn rem(self, rhs: Self) -> Self {
        Self {
            0: self.0.rem(rhs.0),
        }
    }
}

impl RemAssign for X {
    fn rem_assign(&mut self, rhs: Self) {
        self.0.rem_assign(rhs.0);
    }
}

impl Shl for X {
    type Output = Self;

    fn shl(self, rhs: Self) -> Self {
        Self {
            0: self.0.shl(rhs.0),
        }
    }
}

impl ShlAssign for X {
    fn shl_assign(&mut self, rhs: Self) {
        self.0.shl_assign(rhs.0);
    }
}

impl Shr for X {
    type Output = Self;

    fn shr(self, rhs: Self) -> Self {
        Self {
            0: self.0.shr(rhs.0),
        }
    }
}

impl ShrAssign for X {
    fn shr_assign(&mut self, rhs: Self) {
        self.0.shr_assign(rhs.0);
    }
}

impl BitAnd for X {
    type Output = Self;

    fn bitand(self, rhs: Self) -> Self {
        Self {
            0: self.0.bitand(rhs.0),
        }
    }
}

impl BitAndAssign for X {
    fn bitand_assign(&mut self, rhs: Self) {
        self.0.bitand_assign(rhs.0);
    }
}

impl BitOr for X {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Self {
        Self {
            0: self.0.bitor(rhs.0),
        }
    }
}

impl BitOrAssign for X {
    fn bitor_assign(&mut self, rhs: Self) {
        self.0.bitor_assign(rhs.0);
    }
}

impl BitXor for X {
    type Output = Self;

    fn bitxor(self, rhs: Self) -> Self {
        Self {
            0: self.0.bitxor(rhs.0),
        }
    }
}

impl BitXorAssign for X {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.0.bitxor_assign(rhs.0);
    }
}
