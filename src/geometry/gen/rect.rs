////////////////////////////////////////////////////////////////////////////////
// ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ This file is @generated by build script. ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ //
// ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§           â›” DO NOT MODIFY! â›”           ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ //
////////////////////////////////////////////////////////////////////////////////

use super::*;

/// A `(position, size)` [`Size`](crate::Size).
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Default, Debug)]
pub struct Rect {
    pub position: Position,
    pub size:     Size,
}

// ========================================================================== //
// ========================================================================== //
//                                Conversions                                 //
// ========================================================================== //
// ========================================================================== //

impl From<Rect> for ((usize, usize), (usize, usize)) {
    fn from(rect: Rect) -> Self {
        (
            (rect.position.x.0, rect.position.y.0),
            (rect.size.width.0, rect.size.height.0),
        )
    }
}

impl From<usize> for Rect {
    fn from(usize: usize) -> Self {
        Self {
            position: Position {
                x: X(usize),
                y: Y(usize),
            },
            size:     Size {
                width:  Width(usize),
                height: Height(usize),
            },
        }
    }
}

impl From<(usize, usize)> for Rect {
    fn from((position, size): (usize, usize)) -> Self {
        Self {
            position: Position {
                x: X(position),
                y: Y(position),
            },
            size:     Size {
                width:  Width(size),
                height: Height(size),
            },
        }
    }
}

impl From<((usize, usize), (usize, usize))> for Rect {
    fn from(((x, y), (width, height)): ((usize, usize), (usize, usize))) -> Self {
        Self {
            position: Position { x: X(x), y: Y(y) },
            size:     Size {
                width:  Width(width),
                height: Height(height),
            },
        }
    }
}

// ========================================================================== //
// ========================================================================== //
//                                 Operations                                 //
// ========================================================================== //
// ========================================================================== //

impl Not for Rect {
    type Output = Self;

    fn not(self) -> Self {
        Self {
            position: self.position.not(),
            size:     self.size.not(),
        }
    }
}

impl Add for Rect {
    type Output = Self;

    fn add(self, rhs: Self) -> Self {
        Self {
            position: self.position.add(rhs.position),
            size:     self.size.add(rhs.size),
        }
    }
}

impl AddAssign for Rect {
    fn add_assign(&mut self, rhs: Self) {
        self.position.add_assign(rhs.position);
        self.size.add_assign(rhs.size);
    }
}

impl Sub for Rect {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self {
        Self {
            position: self.position.sub(rhs.position),
            size:     self.size.sub(rhs.size),
        }
    }
}

impl SubAssign for Rect {
    fn sub_assign(&mut self, rhs: Self) {
        self.position.sub_assign(rhs.position);
        self.size.sub_assign(rhs.size);
    }
}

impl Mul for Rect {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self {
        Self {
            position: self.position.mul(rhs.position),
            size:     self.size.mul(rhs.size),
        }
    }
}

impl MulAssign for Rect {
    fn mul_assign(&mut self, rhs: Self) {
        self.position.mul_assign(rhs.position);
        self.size.mul_assign(rhs.size);
    }
}

impl Div for Rect {
    type Output = Self;

    fn div(self, rhs: Self) -> Self {
        Self {
            position: self.position.div(rhs.position),
            size:     self.size.div(rhs.size),
        }
    }
}

impl DivAssign for Rect {
    fn div_assign(&mut self, rhs: Self) {
        self.position.div_assign(rhs.position);
        self.size.div_assign(rhs.size);
    }
}

impl Rem for Rect {
    type Output = Self;

    fn rem(self, rhs: Self) -> Self {
        Self {
            position: self.position.rem(rhs.position),
            size:     self.size.rem(rhs.size),
        }
    }
}

impl RemAssign for Rect {
    fn rem_assign(&mut self, rhs: Self) {
        self.position.rem_assign(rhs.position);
        self.size.rem_assign(rhs.size);
    }
}

impl Shl for Rect {
    type Output = Self;

    fn shl(self, rhs: Self) -> Self {
        Self {
            position: self.position.shl(rhs.position),
            size:     self.size.shl(rhs.size),
        }
    }
}

impl ShlAssign for Rect {
    fn shl_assign(&mut self, rhs: Self) {
        self.position.shl_assign(rhs.position);
        self.size.shl_assign(rhs.size);
    }
}

impl Shr for Rect {
    type Output = Self;

    fn shr(self, rhs: Self) -> Self {
        Self {
            position: self.position.shr(rhs.position),
            size:     self.size.shr(rhs.size),
        }
    }
}

impl ShrAssign for Rect {
    fn shr_assign(&mut self, rhs: Self) {
        self.position.shr_assign(rhs.position);
        self.size.shr_assign(rhs.size);
    }
}

impl BitAnd for Rect {
    type Output = Self;

    fn bitand(self, rhs: Self) -> Self {
        Self {
            position: self.position.bitand(rhs.position),
            size:     self.size.bitand(rhs.size),
        }
    }
}

impl BitAndAssign for Rect {
    fn bitand_assign(&mut self, rhs: Self) {
        self.position.bitand_assign(rhs.position);
        self.size.bitand_assign(rhs.size);
    }
}

impl BitOr for Rect {
    type Output = Self;

    fn bitor(self, rhs: Self) -> Self {
        Self {
            position: self.position.bitor(rhs.position),
            size:     self.size.bitor(rhs.size),
        }
    }
}

impl BitOrAssign for Rect {
    fn bitor_assign(&mut self, rhs: Self) {
        self.position.bitor_assign(rhs.position);
        self.size.bitor_assign(rhs.size);
    }
}

impl BitXor for Rect {
    type Output = Self;

    fn bitxor(self, rhs: Self) -> Self {
        Self {
            position: self.position.bitxor(rhs.position),
            size:     self.size.bitxor(rhs.size),
        }
    }
}

impl BitXorAssign for Rect {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.position.bitxor_assign(rhs.position);
        self.size.bitxor_assign(rhs.size);
    }
}
